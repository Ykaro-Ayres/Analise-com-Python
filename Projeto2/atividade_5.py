# -*- coding: utf-8 -*-
"""Atividade 5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZZBf4_3ESdUDqikqezU2OVvbXv4-rwlq
"""

import pandas as pd

df = pd.read_csv("data.csv", sep =",")

print(df.head())

print(df.info())

# Tratamento de dados nulos
df.dropna(inplace=True)

# Verificando que não há mais dados nulos
print(df.info())

# Tratamento de outliers usando IQR
Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR = Q3 - Q1

# Removendo linhas com outliers apenas para colunas numéricas
numeric_columns = df.select_dtypes(include=['number']).columns
df_no_outliers = df[~((df[numeric_columns] < (Q1[numeric_columns] - 1.5 * IQR[numeric_columns])) | (df[numeric_columns] > (Q3[numeric_columns] + 1.5 * IQR[numeric_columns]))).any(axis=1)]

# Verificando as dimensões antes e depois do tratamento
print("Antes do tratamento de outliers:", df.shape)
print("Após o tratamento de outliers:", df_no_outliers.shape)

# Verificando e removendo preços unitários ou quantidades iguais ou inferiores a zero
df = df_no_outliers[(df_no_outliers['UnitPrice'] > 0) & (df_no_outliers['Quantity'] > 0)]

# Confirmando que não hexistem valores nulos ou <= a zero
print(df.info())

# Verificando e removendo observações com valores nulos na identificação do cliente
print("Quantidade de valores nulos em CustomerID:", df['CustomerID'].isna().sum())

# Remover linhas com valores nulos na identificação do cliente
df = df.dropna(subset=['CustomerID'])

# Confirmar que não existem mais valores nulos na identificação do cliente
print(df.info())

# Convertendo a coluna InvoiceDate para o formato datetime
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])

from datetime import datetime

# Verificar e remover preços unitários ou quantidades iguais ou inferiores a zero
df = df[(df['UnitPrice'] > 0) & (df['Quantity'] > 0)]

# Confirmar que não há mais valores nulos ou menores/iguais a zero
print(df.info())

# Calculando a recência (tempo desde a última compra)
max_date = df['InvoiceDate'].max()
df['Recency'] = (max_date - df['InvoiceDate']).dt.days

# Calculando a frequência (quantidade de compras)
rfm_frequency = df.groupby('CustomerID')['InvoiceNo'].nunique().reset_index()
rfm_frequency.columns = ['CustomerID', 'F']

# Calculando o valor total gasto por cliente
df['TotalAmount'] = df['Quantity'] * df['UnitPrice']
rfm_monetary = df.groupby('CustomerID')['TotalAmount'].sum().reset_index()
rfm_monetary.columns = ['CustomerID', 'M']

# Calculando o ticket médio
rfm_monetary['TicketAverage'] = rfm_monetary['M'] / rfm_frequency['F']

# Calculando a recência novamente para evitar conflitos no merge
df_r = df.groupby('CustomerID')['Recency'].min().reset_index()

# Merge das tabelas para obter as métricas RFM
rfm_result = df_r.merge(rfm_frequency, on='CustomerID').merge(rfm_monetary[['CustomerID', 'TicketAverage']], on='CustomerID')

# Salvar o resultado em um novo arquivo CSV
rfm_result.to_csv("output.csv", index=False)

# Primeiras linhas do resultado final
print(rfm_result.head())

# Verificando se existem linhas duplicadas
duplicated_rows = df[df.duplicated()]

# Removendo linhas duplicadas
df = df.drop_duplicates()

# Confirmar que não há mais linhas duplicadas
print("Quantidade de linhas duplicadas antes da remoção:", len(duplicated_rows))
print("Quantidade de linhas duplicadas após a remoção:", len(df[df.duplicated()]))

# Correção dos tipos de dados
df['InvoiceNo'] = df['InvoiceNo'].astype(str)
df['StockCode'] = df['StockCode'].astype(str)
df['Description'] = df['Description'].astype(str)
df['Quantity'] = df['Quantity'].astype(int)
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
df['UnitPrice'] = df['UnitPrice'].astype(float)
df['CustomerID'] = df['CustomerID'].astype(int)
df['Country'] = df['Country'].astype(str)

# Visualizando os novos tipos de dados
print(df.dtypes)

import matplotlib.pyplot as plt
import seaborn as sns

# Criando um gráfico de dispersão para visualizar outliers
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Quantity', y='UnitPrice', data=df)
plt.title('Outliers Antes da Remoção')
plt.xlabel('Quantity')
plt.ylabel('UnitPrice')
plt.show()

# Remover outliers
df = df[(df['Quantity'] <= 10000) & (df['UnitPrice'] <= 5000)]

# Visualizando gráfico novamente após a remoção
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Quantity', y='UnitPrice', data=df)
plt.title('Outliers Após a Remoção')
plt.xlabel('Quantity')
plt.ylabel('UnitPrice')
plt.show()

# Criação de uma coluna adicional com o preço total da compra
df['TotalPurchase'] = df['Quantity'] * df['UnitPrice']
print(df.head())

# Calculando a data da última compra no conjunto de dados
last_purchase_date = df['InvoiceDate'].max()
print("Data da última compra:", last_purchase_date)

import matplotlib.pyplot as plt
import seaborn as sns

# Calculando o valor de venda total por país
total_sales_by_country = df.groupby('Country')['TotalPurchase'].sum().sort_values(ascending=False)

# Selecionar os top 10 países
top_countries = total_sales_by_country.head(10)

# Visualização em gráfico
plt.figure(figsize=(12, 6))
sns.barplot(x=top_countries.values, y=top_countries.index, palette='viridis')
plt.title('Top 10 Países com Maior Valor em Vendas')
plt.xlabel('Valor Total de Vendas')
plt.ylabel('Países')
plt.show()

# Cálculo da quantidade total vendida por produto
total_quantity_by_product = df.groupby('Description')['Quantity'].sum().sort_values(ascending=False)

# Selecionar os top 10 produtos
top_products = total_quantity_by_product.head(10)

# Visualização em gráfico
plt.figure(figsize=(12, 6))
sns.barplot(x=top_products.values, y=top_products.index, palette='mako')
plt.title('Top 10 Produtos Mais Vendidos')
plt.xlabel('Quantidade Total Vendida')
plt.ylabel('Produtos')
plt.show()

# Criando uma coluna com o mês da compra
df['Month'] = df['InvoiceDate'].dt.month

# Calculando o valor total de vendas por mês
total_sales_by_month = df.groupby('Month')['TotalPurchase'].sum()

# Mapear os números do mês para seus nomes
month_names = {1: 'Janeiro', 2: 'Fevereiro', 3: 'Março', 4: 'Abril', 5: 'Maio', 6: 'Junho',
               7: 'Julho', 8: 'Agosto', 9: 'Setembro', 10: 'Outubro', 11: 'Novembro', 12: 'Dezembro'}

# Ordenar os meses
total_sales_by_month = total_sales_by_month.sort_index()

# Visualizar gráfico
plt.figure(figsize=(15, 6))
sns.lineplot(x=total_sales_by_month.index.map(month_names), y=total_sales_by_month.values, marker='o', color='blue')
plt.title('Valor de Venda Total por Mês')
plt.xlabel('Mês')
plt.ylabel('Valor Total de Vendas')
plt.show()

# Calculo do valor de venda total por mês e por país (considerando apenas os top 10)
total_sales_by_month_country = df.groupby(['Month', 'Country'])['TotalPurchase'].sum().reset_index()

# Selecionar os top 10 países
top_countries = total_sales_by_country.head(10).index

# Filtrar apenas os top 10 países
total_sales_by_month_country_top10 = total_sales_by_month_country[total_sales_by_month_country['Country'].isin(top_countries)]

# Gráfico de barras agrupado por país
plt.figure(figsize=(14, 8))
sns.barplot(x='Month', y='TotalPurchase', hue='Country', data=total_sales_by_month_country_top10, palette='Set2')
plt.title('Valor de Venda Total por Mês e por País (Top 10)')
plt.xlabel('Mês')
plt.ylabel('Valor Total de Vendas')
plt.legend(title='País', loc='upper right', bbox_to_anchor=(1.2, 1))
plt.show()

# Calcular RFM
rfm_data = df.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (last_purchase_date - x.max()).days,  # Recência
    'InvoiceNo': 'nunique',  # Frequência
    'TotalPurchase': 'mean'  # Média de compras
}).reset_index()

# Renomear colunas para RFM
rfm_data.columns = ['CustomerID', 'Recency', 'Frequency', 'Monetary']

# Calcular média das compras por cliente
rfm_avg_purchase = df.groupby('CustomerID')['TotalPurchase'].mean().reset_index()
rfm_avg_purchase.columns = ['CustomerID', 'AvgPurchase']

# Merge dos resultados para obter o RFM completo
rfm_data = rfm_data.merge(rfm_avg_purchase, on='CustomerID')

# Renomear colunas para RFM
rfm_data.columns = ['CustomerID', 'InvoiceNo', 'Recency', 'Frequency', 'Monetary']

# Visualizar as primeiras linhas do resultado
print(rfm_data.head())